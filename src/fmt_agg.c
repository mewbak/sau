// Credits go to A. Afletdinov, author of Free Heroes2 Engine

//note that 82M are raw audio files in format of 8-bit unsigned mono 22050Hz.
//so they can be converted to wav using the following code
// for i in *.82M; do mv "$i" "$i.raw"; done
// for i in *.raw; do sox -r 22050 -e unsigned -b 8 -c 1 "$i" "$(echo "$i" | sed 's/.82M.raw/.wav/')"; done


#include "common.h"

static const u1 Pal[] = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0x3f,
  0x3f,0x3c,0x3c,0x3c,0x3a,0x3a,0x3a,0x37,0x37,0x37,0x35,0x35,0x35,0x32,0x32,0x32,
  0x30,0x30,0x30,0x2d,0x2d,0x2d,0x2b,0x2b,0x2b,0x29,0x29,0x29,0x26,0x26,0x26,0x24,
  0x24,0x24,0x21,0x21,0x21,0x1f,0x1f,0x1f,0x1c,0x1c,0x1c,0x1a,0x1a,0x1a,0x17,0x17,
  0x17,0x15,0x15,0x15,0x12,0x12,0x12,0x10,0x10,0x10,0x0e,0x0e,0x0e,0x0b,0x0b,0x0b,
  0x09,0x09,0x09,0x06,0x06,0x06,0x04,0x04,0x04,0x01,0x01,0x01,0x00,0x00,0x00,0x3f,
  0x3b,0x37,0x3c,0x37,0x32,0x3a,0x34,0x2e,0x38,0x31,0x2a,0x36,0x2e,0x26,0x34,0x2a,
  0x22,0x32,0x28,0x1e,0x30,0x25,0x1b,0x2e,0x22,0x18,0x2b,0x1f,0x15,0x29,0x1c,0x12,
  0x27,0x1a,0x0f,0x25,0x18,0x0d,0x23,0x15,0x0b,0x21,0x13,0x08,0x1f,0x11,0x07,0x1d,
  0x0f,0x05,0x1a,0x0d,0x04,0x18,0x0c,0x03,0x16,0x0a,0x02,0x14,0x09,0x01,0x12,0x07,
  0x01,0x0f,0x06,0x00,0x0d,0x05,0x00,0x0b,0x04,0x00,0x09,0x03,0x00,0x30,0x33,0x3f,
  0x2b,0x2e,0x3c,0x26,0x2a,0x3a,0x22,0x26,0x38,0x1e,0x22,0x36,0x1a,0x1e,0x34,0x16,
  0x1a,0x31,0x13,0x16,0x2f,0x10,0x13,0x2d,0x0d,0x10,0x2b,0x0a,0x0d,0x29,0x08,0x0c,
  0x26,0x07,0x0a,0x24,0x05,0x09,0x22,0x04,0x08,0x20,0x03,0x07,0x1e,0x02,0x06,0x1c,
  0x01,0x05,0x19,0x01,0x05,0x17,0x00,0x04,0x15,0x00,0x03,0x13,0x00,0x03,0x11,0x2b,
  0x38,0x27,0x27,0x35,0x23,0x24,0x33,0x20,0x20,0x30,0x1c,0x1d,0x2e,0x19,0x1a,0x2c,
  0x17,0x17,0x29,0x14,0x14,0x27,0x11,0x12,0x24,0x0f,0x0f,0x22,0x0c,0x0d,0x1f,0x0a,
  0x0b,0x1d,0x09,0x09,0x1b,0x07,0x08,0x19,0x06,0x06,0x17,0x05,0x05,0x15,0x03,0x03,
  0x13,0x02,0x02,0x10,0x01,0x01,0x0e,0x01,0x01,0x0c,0x00,0x00,0x0a,0x00,0x00,0x08,
  0x00,0x00,0x06,0x00,0x3f,0x3d,0x34,0x3e,0x3a,0x2b,0x3d,0x38,0x23,0x3c,0x37,0x1b,
  0x3b,0x35,0x14,0x3a,0x33,0x0d,0x39,0x32,0x05,0x38,0x31,0x00,0x36,0x2f,0x08,0x34,
  0x2c,0x07,0x32,0x28,0x06,0x2f,0x26,0x06,0x2d,0x23,0x06,0x2a,0x1f,0x05,0x27,0x1c,
  0x04,0x25,0x19,0x03,0x22,0x16,0x03,0x1f,0x13,0x02,0x1d,0x11,0x02,0x1a,0x0f,0x00,
  0x18,0x0c,0x00,0x15,0x0a,0x00,0x13,0x08,0x00,0x39,0x33,0x3e,0x36,0x2f,0x3b,0x32,
  0x2a,0x39,0x30,0x27,0x36,0x2d,0x23,0x34,0x2a,0x1f,0x31,0x27,0x1c,0x2f,0x24,0x19,
  0x2d,0x21,0x16,0x2a,0x1e,0x13,0x28,0x1c,0x11,0x25,0x19,0x0e,0x23,0x17,0x0c,0x20,
  0x14,0x0a,0x1e,0x12,0x08,0x1b,0x10,0x06,0x19,0x0e,0x05,0x17,0x0b,0x02,0x14,0x08,
  0x01,0x11,0x06,0x00,0x0e,0x04,0x00,0x0b,0x2d,0x3d,0x3f,0x2a,0x3a,0x3c,0x28,0x38,
  0x3a,0x25,0x36,0x38,0x22,0x33,0x35,0x20,0x31,0x33,0x1e,0x2e,0x31,0x1c,0x2c,0x2f,
  0x19,0x2a,0x2c,0x17,0x27,0x2a,0x16,0x25,0x28,0x14,0x23,0x25,0x12,0x20,0x23,0x10,
  0x1d,0x20,0x0e,0x1a,0x1d,0x0c,0x18,0x1b,0x0a,0x15,0x18,0x08,0x13,0x16,0x07,0x10,
  0x13,0x05,0x0e,0x10,0x04,0x0b,0x0e,0x03,0x09,0x0b,0x02,0x07,0x09,0x3f,0x39,0x39,
  0x3d,0x34,0x34,0x3c,0x2f,0x2f,0x3a,0x2b,0x2b,0x39,0x27,0x27,0x37,0x23,0x23,0x36,
  0x1f,0x1f,0x34,0x1b,0x1b,0x33,0x17,0x17,0x31,0x14,0x14,0x30,0x11,0x11,0x2f,0x0e,
  0x0e,0x2e,0x0b,0x0b,0x2d,0x09,0x09,0x2a,0x08,0x08,0x27,0x06,0x06,0x24,0x04,0x04,
  0x21,0x03,0x03,0x1e,0x02,0x02,0x1b,0x01,0x01,0x18,0x00,0x00,0x15,0x00,0x00,0x12,
  0x00,0x00,0x3f,0x39,0x27,0x3e,0x36,0x23,0x3d,0x34,0x1f,0x3c,0x31,0x1c,0x3b,0x2e,
  0x18,0x3a,0x2b,0x14,0x39,0x28,0x11,0x38,0x24,0x0e,0x38,0x21,0x0b,0x33,0x1d,0x08,
  0x2e,0x19,0x06,0x29,0x16,0x04,0x25,0x12,0x02,0x20,0x0f,0x01,0x1b,0x0c,0x00,0x17,
  0x0a,0x00,0x3f,0x16,0x03,0x37,0x0d,0x01,0x30,0x05,0x00,0x29,0x00,0x00,0x3f,0x3f,
  0x00,0x3f,0x33,0x00,0x30,0x23,0x00,0x23,0x12,0x00,0x29,0x34,0x00,0x25,0x2f,0x00,
  0x21,0x2b,0x00,0x1e,0x27,0x01,0x1a,0x23,0x01,0x17,0x1e,0x01,0x13,0x1a,0x01,0x10,
  0x16,0x01,0x0d,0x12,0x01,0x0a,0x1e,0x34,0x06,0x1a,0x31,0x01,0x12,0x2d,0x00,0x0e,
  0x2b,0x03,0x15,0x2f,0x00,0x0e,0x2b,0x00,0x10,0x2d,0x21,0x38,0x3f,0x00,0x26,0x3f,
  0x00,0x14,0x39,0x00,0x00,0x29,0x23,0x23,0x2f,0x1c,0x1c,0x27,0x15,0x15,0x1f,0x0f,
  0x0f,0x17,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};


typedef struct {
  u2 U;
  u4 Off;
  u4 Len;
  u4 Len2;
} __attribute__ ((packed)) entryH1;

typedef struct {
  u4 U;
  u4 Off;
  u4 Len;
} __attribute__ ((packed)) entryH2;

typedef struct {
  u2 N;
  u2 W;
  u2 H;
  //u1 Tiles[NFrames][Width*Height];
} __attribute__ ((packed)) til;

typedef struct {
  u2 N; // number of frames
  u4 L; // size of whole ICN file, excluding header
  //FrameHeader Hs[NFrames];
} __attribute__ ((packed)) icn;

typedef struct {
  s2 X; // X/Y displacement
  s2 Y;
  u2 W;
  u2 H;
  u1 U;
  u4 Off;  // offset of palette minus sizeof(icn)
} __attribute__ ((packed)) icnFrame;


static void saveTIL (char *Output, u1 *M, int L) {
  int I, TX=0,TY=0, X,Y,W,H, TPL=32;
  til *T = (til*)M;
  u1 *Q = (u1*)(T+1);
  pic *P = picNew(TPL*T->W, (T->N+TPL-1)/TPL*T->H, 8);

  times (I, T->N) {
    times (Y, T->H) times (X, T->W) picPut(P, TX+X, TY+Y, *Q++);
    if (!I || I%TPL) TX += T->W;
    else TX = 0, TY += T->H;
  }

  times (I, 256) {
    P->P[I*4+0] = Pal[I*3+0]<<2;
    P->P[I*4+1] = Pal[I*3+1]<<2;
    P->P[I*4+2] = Pal[I*3+2]<<2;
    P->P[I*4+3] = 0;
  }

  strcpy(Output+strlen(Output)-3, "png");
  pngSave(Output, P);
}

// RLE decoding code, adapted from fheroes.
static void decode(pic *P, u4 size, u1 *vdata) {
  u1 i, count;
  u2 x = 0;
  u2 y = 0;
  u4 index = 0;

  while(index < size) {
    if(0 == vdata[index]) { // 0x00 - end line
        ++y;
        x = 0;
        ++index;
        continue;
    } else if(0x80 > vdata[index]) { // range 0x01..0x7F XX
        count = vdata[index];
        ++index;
        for(i = 0; i < count && index < size; i++, x++, index++)
          P->D[y*P->I+x] = vdata[index];
        continue;
    } else if(0x80 == vdata[index]) { break; // end data
    } else if(0x80 < vdata[index] && 0xC0 > vdata[index]) { // range 0x81..0xBF 00
        x += (vdata[index] - 0x80);
        ++index;
        continue;
    } else if(0xC0 == vdata[index]) { // 0xC0 - seek
        ++index;
        if(0 == vdata[index] % 4) {
          count = vdata[index];
          ++index;
          for(i = 0; i < vdata[index]; i++, x++) {
            //P->D[y*P->I+x] = shadow;
          }
          ++index;
          continue;
        } else {
          count = vdata[index];
          for(i = 0; i < vdata[index] % 4; i++, x++) {
            //P->D[y*P->I+x] = shadow;
          }
          ++index;
          continue;
        }
    } else if(0xC1 == vdata[index]) { // 0xC1 N D count - data
        ++index;
        count = vdata[index];
        ++index;
        for(i = 0; i < count; i++, x++) P->D[y*P->I+x] = vdata[index];
        ++index;
        continue;
    } else if(0xC1 < vdata[index]) { // 0xC2 more
        count = vdata[index] - 0xC0;
        ++index;
        for(i = 0; i < count; i++, x++) P->D[y*P->I+x] = vdata[index];
        ++index;
        continue;
    }
  }
}

static void saveICN (char *Output, u1 *M, int L) {
  int I, J, Len;
  char Tmp[1024];
  u1 *Q, *Z;
  pic *P;
  icn *H = (icn*)M;
  icnFrame *F = (icnFrame *)(H+1);

  times (I, H->N) {
    P = picNew(F[I].W, F[I].H, 8);
    P->K = 0;
    times (J, 256) {
      P->P[J*4+0] = Pal[J*3+0]<<2;
      P->P[J*4+1] = Pal[J*3+1]<<2;
      P->P[J*4+2] = Pal[J*3+2]<<2;
      P->P[J*4+3] = 0;
    }

    Len = (I+1!=H->N ? F[I+1].Off : L) - F[I].Off;
    Z = M+sizeof(icn)+F[I].Off;
    Q = ns(u1, Len+100);
    memset(Q, 0x80, Len+100);
    memcpy(Q, Z, Len);
    decode(P, Len, Q);
    sprintf(Tmp, "%s/%03d.png", Output, I);
    pngSave(Tmp, P);
  }
}

//FIXME: HOMM1 uses a little different sprite format
static void aggDecompile (char *Output, char *Input) {  
  int I, Homm2, Off, Len;
  char Tmp[1024], Ext[32], Name[16];
  int L = fileSize(Input);
  u1 *M = readFile(0, L, Input);;
  int NFiles = *(u2*)M;
  Name[15] = 0;

  pathParts(0, Tmp, 0, Input);
  downcase(Tmp);
  Homm2 = strcmp(Tmp, "heroes");

  times (I, NFiles) {
    memcpy(Name, M + L - (NFiles-I)*15, 15);
    pathParts(0,0,Ext,Name);
    if (Homm2) {
      entryH2 *Es = (entryH2*)(M+2)+I;
      Off = Es->Off;
      Len = Es->Len;
    } else {
      entryH1 *Es = (entryH1*)(M+2)+I;
      Off = Es->Off;
      Len = Es->Len;
    }
    printf("Extracting: %s\n", Name);
    printf("  Off=#%08x Len=#%08x\n", Off, Len);
    sprintf(Tmp, "%s/%s/%s", Output, Ext, Name);
    if (!strcmp(Ext,"ICN")) saveICN(Tmp, M+Off, Len);
    else if (!strcmp(Ext,"TIL")) saveTIL(Tmp, M+Off, Len);
    else {
      writeFile(0, Len, Tmp, M+Off);
    }
  }
}

int aggInit(format *F) {
  F->Type = FMT_ARCHIVE;
  F->Name = "agg";
  F->Description = "Heroes of Might & Magic 1-2";
  F->Decompile = aggDecompile;
  return 1;
}

